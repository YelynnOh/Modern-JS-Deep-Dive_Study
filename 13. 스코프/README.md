# 13. 스코프(scope)

## 1. 스코프란?

스코프는 식별자가 유효한 범위를 말한다.
모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정되며, 이를 스코프라고 한다. 

아래에서 1, 2에 들어갈 값을 맞춰보자.
```js
var x = 'global';

function foo() {
  var x = 'local';
  console.log(x + ddd); //1
}

foo();

console.log(x); //2
```
1번에는 'local'이 출력이 되고, 2번에는 'global' 출력이 된다. 이는 __식별자 결정(identifier resolution) 과정 때문에 일어난다.__

📌 __식별자 결정__
- 자바스크립트 엔진이 이름이 같은 두 개의 변수가 있을 때 어떤 변수를 참조해야할 지 결정을 하는 것
- 이때, 자바스크립트 엔진은 스코프를 사용해서 식별자를 결정하게 된다. 

> 자바스크립트 엔진은 코드를 실행할 때 _코드의 문맥(context)_ 를 고려한다. 즉, 코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 나타내는 _렉시컬 환경_ 을 고려하는 것이다. 
> 렉시컬 환경을 구현한 것이 _실행 컨텍스트(execution context)_ 이며, 모든 코드는 실행 컨텍스트에서 평가되고 실행된다. 스코프는 실행 컨텍스트와 깊은 관련이 있다.

스코프(유효범위)가 있음으로서 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있다. 예시로는 `var`이 있다.
```js
function foo() {
  var x = 1;
  //var 키워드로 선언된 벼수는 같은 스코프 내에서 중복 선언이 허용된다.
  //아래 변수 선언문은 JS 엔진에 의해 var 키워드가 없는 것처럼 동작한다.
  var x = 2;
  console.log(x); //2
}
foo();

//let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않아 SyntaxError가 발생한다.
```

## 2. 스코프의 종류

| 구분 | 설명 | 스코프 | 변수 |
| --- | --- | --- | --- |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 | 함수 몸체 내부 | 지역 스코프  | 지역 변수 |

변수는 자신이 선언된 위치(전역 or 지역)에 의해 자신이 유효한 범위인 스코프가 결정된다.

```js
var x = 'global x';
var y = 'global y';

function outer(){
  var z = 'outer's local z';

  console.log(x); //1) global x
  console.log(y); //2) global y
  console.log(z); //3) outer's local z

  function inner() {
    var x = 'inner's local x';

    console.log(x); //4) inner's local x
    console.log(y); //5) global y
    console.log(z); //6) outer's local z
  }
  inner();
}

outer();

console.log(x); //7) global x
console.log(z); //8) ReferenceError: z is not defined


```


### 전역과 전역 스코프

전역 변수는 _어디서든지 참조할 수 있다._

### 지역과 지역 스코프

지역이란 _함수 몸체 내부를 의미한다._
지역 변수는 _자신의 지역 스코프와 하위 지역 스코프에서 유효하다._

## 3. 스코프 체인

![image](https://github.com/YelynnOh/Modern-JS-Deep-Dive_Study/assets/110076475/b2bb5a60-76e4-4e17-9ace-ff2629fc1391)

스코프가 계층적으로 연결된 것을 스코프 체인(scope chain)이라고 한다. 

__변수를 참조할 때 JS 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색(identifier resolution)한다.__
때문에 상위 스코프에서 선언한 변수는 하위 스코프에서도 참조가 가능하다.

📌 렉시컬 환경
- 스코프 체인은 물리적인 실제로 존재한다. JS 엔진은 코드를 실행하기 전에 렉시컬 환경(lexical environment)를 실제로 생성한다. 변수 선언이 실행되면 변수 식별자가 이 렉시컬 환경(자료구조)에 키(key)로 등록되고, 변수 할당이 일어나면 자료구조의 변수 식별자에 해당하는 값을 변경한다. 변수의 검색도 이 자료구조 상에서 이뤄진다.
- 스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것이다. 

### 스코프 체인에 의한 변수 검색

위에 코드에서 4, 5, 6을 보면 JS 엔진이 스코프 체인을 통해 어덯게 변수를 찾는지 이해할 수 있다.

__4__ <br>
x 변수를 참조하는 코드 스코프인 inner 함수의 지역 스코프에서 x 변수가 선언되었는지 검색 > x 존재함 > 검색된 변수 참조 후 검색 종료

__5__ <br>
y 변수 참조하는 코드의 스코프인 inner 함수의 지역 스코프에서 y 변수 선언되었는지 검색 > inner 함수 내에는 y 변수 선언이 존재하지 않으므로 상위 스코프인 outer 함수의 지역 스코프로 이동 > outer에도 없음 > 상위 스코프인 전역 스코프로 이동 > y 변수 참조하고 검색 종료

__6__ <br>
inner에서 있는지 확인 > 없으니 outer로 이동해 z 변수 선언되었는지 확인 > 있으므로 참조 후 검색 종료

__상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다.__

### 스코프 체인에 의한 함수 검색

함수도 식별자에 할당되기 때문에 스코프를 갖는다. 

```js
// 전역 함수
function foo() {
    console.log("global function foo");
}

function bar() {
    // 중첩 함수
    function foo() {
        console.log("local function foo");
    }
    foo();  // local function foo
}

bar();
```

1) 함수 선언문으로 함수 정의
2) 런타임 이전에 함수 객체 생성
3) 함수 이름과 동일한 이름의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 할당한다.

## 4. 함수 레벨 스코프

코드 블록이 아닌 함수에 의해서만 지역 스코프는 생성이 된다.

- 블록 레벨 스코프(block level scope) : 함수 몸체만이 아니라 모든 코드 블록(if, for, while, try/catch)이 지역 스코프를 만듦. 예로 C나 자바가 있음
- 함수 레벨 스코프(function level scope) : __`var` 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다.__

```js
var x = 1;

if (true) {
  // var 키워드로 선언된 변수는 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다.
  // 함수 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언되었다 할지라도 모두 전역 변수다.
  // 따라서 x는 전역 변수다. 이미 선언된 전역 변수 x가 있으므로 x 변수는 중복 선언된다.
  // 이는 의도치 않게 변수 값이 변경되는 부작용을 발생시킨다.
  var x = 10; // 전역 스코프에 선언한 전역 변수
}

console.log(x); // 10
```
```js
var i = 10;

// for 문에서 선언한 i는 전역 변수다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.
for (var i = 0; i < 5; i++) {
    console.log(i); // 0 1 2 3 4
}

// 의도치 않게 변수의 값이 변경되었다.
console.log(i); // 5
```
`var` 키워드의 경우 함수의 코드 블록만을 지역 스코프로 인정하지만 ES6의 `let`, `const` 키워드는 블록 레벨 스코프를 지원한다.

## 5. 렉시컬 스코프

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

놀랍게도 두 실행 값은 모두 1이다.😳

해당 예제의 결과는 `bar` 함수의 상위 스코프가 무엇인지에 따라 결정된다.
  1. __함수를 어디에서 호출했는지__ 에 따라 함수의 상위 스코프를 결정한다. > __동적 스코프__
  2. __함수를 어디에서 정의했는지__ 에 따라 함수의 상위 스코프를 결정한다. > __렉시컬 스코프__

JS는 _렉시컬 스코프_ 를 따른다. 따라서 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.
함수가 호출된 위치는 상위 스코프 결정에 어떤 영향을 주지 않는다. 즉, __함수의 상위 스코프는 언제나 자신이 정의된 스코프다.__

때문에 함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정된다. 함수 정의가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억한다. 함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 때문이다.

따라서 `bar` 함수는 전역에서 정의된 함수이다.
전역 코드가 실행되기 전에 먼저 평가된 `bar` 함수는 함수 객체를 생성하며, 자신이 정의된 스코프, 즉 전역 스코프를 기억한다.
즉, 전역 스코프가 상위 스코프가 되는 것이다. 따라서 결과 값은 모두 1이 된다.

렉시컬 스코프는 클로저와 깊은 관계가 있다고 한다.

